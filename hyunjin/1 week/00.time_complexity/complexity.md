# 시간 복잡도

알고리즘은 결국 해당 알고리즘을 실행하는데 시간이 얼마나 필요한가? 를 염두에 둘 수 밖에 없음.

복잡하면 복잡할수록 시간이 더 많이 필요하니까.

그렇다고 해서 걸리는 시간만 측정하기엔 컴퓨터의 성능에 따라 시간이 달라지고, 부정확한 방법이기도 함.

중점은 **입력 값이 커질 때에도 얼마나 효율적으로** 일을 처리할 수 있는가.

**연산 횟수에 비해 시간이 얼마나 걸리는가?** 이기도 함.

## 빅-오-표기법

이러한 시간 복잡도를 나타내는 방법 중 하나가 Big-O 표기법

영향을 가장 많이 끼치는 것을 남기고 나머지는 다 지워버리는 것. (최악만 상정한다고 보면 되려나?)

### 빅-오-표기법에서 O(1)의 복잡성을 가지는 것

간단한 if문, 사칙연산, 배열에서 인덱스 참조, 입력과 출력 등은 입력값의 크기에 따라 복잡도가 변하지 않음.

### 입력값이 하나만 있을 때.

**영향을 가장 많이 끼치는 것**이 무엇인지를 생각하면 됨.

### 입력값이 여러개 있을 때.

N과 M같이 입력값을 여러개 받을 때엔 어떻게 시간복잡도를 구할수 있는가?

일단 N과 M을 각각 놓고 나열한다.

중첩되어있다면 N*M이고. 아니면 N+M이 되는 식.

### 그럼 재귀함수는 어떻게 함?

"몇 번 호출 됐는지가" 중요함. 결국 중요한 건 해당 함수가 몇 번 호출 됐는지를 추적하면 됨.

**디버깅을 하고, 손 코딩을 하고, 그림을 그려서 따라가는 방법**도 있음.

빅-오-표기법에선 결국 중요한 건 가장 영향을 가장 많이 끼치는 것.

#### 그럼 재귀함수에 메인 로직이 붙어있으면?

재귀함수를 몇 번 호출하는지 * 메인 로직

## 점화식

디버깅을 하면서 쫒아가는 건 결국 어림잡아서 하는 것.

시간이 남는다면 점화식을 구해서 하는 방법도 있음. (무조건 하라는게 아님!!)

## 로그

로그(log)는 지수 함수의 역함수. 어떤 수를 나타내기 위해 고정된 밑을 몇 번 곱하여야 하는지를 나타낸다고 보면 됨.

